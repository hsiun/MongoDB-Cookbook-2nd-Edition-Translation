# 启动一个两个分片的简单分片环境

在本菜谱中，我们将设置一个有两个数据分片组成的简单分片。作为用来演示概念的最基本的分片设置，分片本身没有配置副本集。我们不会深入分片，这部分内容将会在管理员部分进行探索。


在我们实践之前先来点理论。扩展性和可用性是构建任何任务启动性应用的重要基石。可用性是一些与副本集相关的东西，这个我们已经在本章前面的菜谱中讨论了。现在让我们看下扩展性。简单的来说，扩展性性就是系统可以容易的复制增长的数据和请求负载。考虑一个电商平台。在平时，网站访问量和负载是相当平和的，并且系统的响应时间和错误率也很小。（这是主观上的。）现在，考虑某一天，在感恩节，圣诞和其他日子里系统负载变成平均负载的两倍，三倍，甚至更多。如果平台在这些高负载的日志里和其他任何日子一样级别提供服务，这个系统就被称之为在大量突发请求有好的横向扩展。


现在考虑一个归档应用，它需要存储在过去的时间内所有命中某个特定网站的请求，我们在底层数据存储中创建一个新的记录。每一次请求命中网站，我们在底层数据存储中创建一个新的记录。假设每个记录有250byte，平均负载每天三百万请求，在五天里我们将到达1TB数据量。这些数据将被用于多种分析目的，也行会频繁查询。当数据量增长查询操作不会有太大的影响。如果系统可以应付这些增长的数据量，并且仍然能够提供与低数据量上的性能相当的可靠性能，这个系统被称之为有好的扩展性。


现在我们大概知道什么是扩展性了，让我告诉你，分片是一种机制，让系统能随请求增加。关键在于以下事实：整个数据被分割成更小的段并且分布在称为分片的各个节点上。假设我们总共有一千万文旦在mongo集合中。如果我们划分这个集合到10个分片上，然后我们将想到会有10,000,000/10 = 1,000,000文档在每个分片。在给定的时间点，一个文档将仅保留在一个分片上（在生产环境每个分片将是一个副本集）。然而，有些神奇的调用是的这些概念对于开发者是隐藏的，开发者查询集合并且获取一个统一的集合视图而不考虑碎片的数量。在查询的情况，mongo决定从哪个分片查询数据，并且反馈整个结果集。有了这个背景，让我们设置一个简单的碎片，仔细看看它。


### 前提条件
除了已经安装的MongoDB服务器，从软件角度看没有先决条件。我们将创建两个数据目录，一个分片一个目录。将会有一个数据和一个日志目录。


### 如何做...
1. 我们通过为日志和数据创建目录开始。创建下面目录，`/data/s1/db`, `/data/s2/db`, 和`/logs`。在Windows中，我们有` c:\data\s1\db`等目录为数据和日志。还有一个配置服务器用来在分片环境中存储一些元信息。我们将使用` /data/
con1/db`作为配置服务器的的数据目录。

2. 启动下面的mongod进程，两个分片一个分片一个，一个给配置数据库，一个给mongos进程。对于Windows平台，跳过`--fork`参数，由于它不被Windows支持。
```
$ mongod --shardsvr --dbpath /data/s1/db --port 27000 --logpath /
logs/s1.log --smallfiles --oplogSize 128 --fork
$ mongod --shardsvr --dbpath /data/s2/db --port 27001 --logpath /
logs/s2.log --smallfiles --oplogSize 128 --fork
$ mongod --configsvr --dbpath /data/con1/db --port 25000
--logpath /logs/config.log --fork
$ mongos --configdb localhost:25000 --logpath /logs/mongos.log
--fork
```

3. 从命令行执行下面命令。这将会展示如下所示的mongos提示符：
```
$ mongo
MongoDB shell version: 3.0.2
connecting to: test
mongos>
```

4. 最后，我们设置分片。从mongos shell执行下面两条命令：
```
mongos> sh.addShard("localhost:27000")
mongos> sh.addShard("localhost:27001")
```

5. 在每个添加的分片，我们应该获取一个ok的返回。添加上的每个分片应该都会返回一个不同ID如下的JSON信息应该：
```
{ "shardAdded" : "shard0000", "ok" : 1 }
```

> 我们到处使用localhost来引用本地运行的服务。这种方式是不推荐的，并且不鼓励。更好的方式是使用主机名
> ，即使他们是本地进程。


### 如何做...
一起看下我们在过程中做了什么。我们为数据创建了三个目录（来个给分片，一个给配置数据库）并且一个目录给日志。我们也可以使用shell脚本或者是批处理文件来创建这些目录。事实上，在大规模产品部署中，手动设置分片不是太消耗时间但是容易导致错误。

> 下载示例代码
> 你可以下载所有你从你账号在< http://www.packtpub.com>购买Packt书籍示例代码。无论你在哪里购买这本书，你都可以访问<http://www.
packtpub.com/support>并注册包含文件的电子邮件将直接发给你。

让我们拿个图片来看下我们已经做了什么以及尝试实现什么。下面这个图片是我们设置的分片：

如果我们看着上面的图片，并且服务已经在第二步启动，我们已经有了可以用来存储事实数据在集合中分片服务。四个进程中的前两个我们启动监听了27000和27001端口。下一步，我们启动配置服务器，配置服务器在这个图片上看起来是在左边的。它是在第二步中的四个服务器中第三个启动的。并且它监听25000端口接受到来的链接。这个数据库的唯一目的及时用来为何分片服务的元信息。理想情况，只有mongos进程或者驱动连接到这个服务器获取分片详情/元信息和分片键信息。我们将在下一个菜谱了解什么是分片键，在下一个菜谱我们摆弄一个分片集合并且看看我们实际创建的是一个什么样的分片。

最终，我们启动了mongos经常。这是一个轻量化的经常，它不需要任何持久化数据且只是从客户端接受连接。这是扮演看门人的一层并且从分片的概念中抽象出客户端。现在，我们可以看到他是作为一个依靠配置服务器给出结果的基础路由器，并且做出决定路由客户端查询到具体的分片服务器执行。然后如果有的话他从多个分片合并结果，并返回结果给客户端。可以负责的说，没有客户端之间连到配置或分片服务器；事实上，应该没有一个人想直接连接到这些进程，处理了执行一些管理员操作。可缓简单的连接到mongos进程并执行它的查询和插入或者更新操作。

只启动分片服务器，配置服务器，和mongos进程但是不创建分片环境。在启动mongos进程时，我们提供给他配置服务器的细节。哪两个分片将要存储实际的数据呢？然而，这两个mongod进程启动作为分片服务器目前还没有声明在配置的任何地方。这正是我们在最后一步中通过为两个分片服务器调用`sh.addShard()`来完成的。配置服务器的细节在mongos进程在启动的时候提供。从shell添加分片将关于分片的元数据存储在配置数据库中，然后mongos进程将在这个配置数据库中查询分片的信息。操作完本菜谱的所有步骤，我们就有了一个如下所示的分片：


在我们结束之前，我们这里设置的分片离理想状态还很远，而不是如何在生产环境中完成。前面的图片给我们在一个产品环境中一个想象中典型分片的模样分片的树莓不会是两个而是更多。另外，每个分片将会是一个副本集来保证高可用。将会由三个配置服务器来部分配置服务的高可用。类似的，可以为分片创建任意数目的mongos进程来监听客户端连接。在一些情况中，它甚至可能启动在苦短应用的服务器上。

### 更多...
除非我们采取行动否则我们不知道分片有什么好处，另外了解下从shell中执行插入和查询数据时发生了什么？在下面菜谱，我们将使用分片设置，添加一些数据，并且观察它的行为。

